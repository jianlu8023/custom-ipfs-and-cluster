package storage

import (
	"encoding/json"
	"errors"
	"strconv"
	"strings"
	"time"

	"github.com/kelseyhightower/envconfig"

	"github.com/ipfs-cluster/ipfs-cluster/config"
)

const configKey = "storage"
const envConfigKey = "cluster_storage"

// Default values for disk Config
const (
	DefaultMetricTTL   = 30 * time.Second
	DefaultMetricMount = defaultMount
)

// Config is used to initialize an Informer and customize
// the type and parameters of the metric it produces.
type Config struct {
	config.Saver

	MetricTTL   time.Duration
	MetricMount string
}

type jsonConfig struct {
	MetricTTL   string `json:"metric_ttl"`
	MetricMount string `json:"metric_mount"`
}

// ConfigKey returns a human-friendly identifier for this type of Metric.
func (cfg *Config) ConfigKey() string {
	return configKey
}

// Default initializes this Config with sensible values.
func (cfg *Config) Default() error {
	cfg.MetricTTL = DefaultMetricTTL
	cfg.MetricMount = DefaultMetricMount
	return nil
}

// ApplyEnvVars fills in any Config fields found
// as environment variables.
func (cfg *Config) ApplyEnvVars() error {
	jcfg := cfg.toJSONConfig()

	err := envconfig.Process(envConfigKey, jcfg)
	if err != nil {
		return err
	}

	return cfg.applyJSONConfig(jcfg)
}

// Validate checks that the fields of this Config have working values,
// at least in appearance.
func (cfg *Config) Validate() error {
	if cfg.MetricTTL <= 0 {
		return errors.New("storage.metric_ttl is invalid")
	}

	if cfg.MetricMount == "" {
		return errors.New("storage.metric_mount is invalid")
	}
	return nil
}

// LoadJSON reads the fields of this Config from a JSON byteslice as
// generated by ToJSON.
func (cfg *Config) LoadJSON(raw []byte) error {
	jcfg := &jsonConfig{}
	err := json.Unmarshal(raw, jcfg)
	if err != nil {
		logger.Error("Error unmarshaling storage informer config")
		return err
	}

	cfg.Default()

	return cfg.applyJSONConfig(jcfg)
}

func (cfg *Config) applyJSONConfig(jcfg *jsonConfig) error {
	t, _ := time.ParseDuration(jcfg.MetricTTL)
	cfg.MetricTTL = t
	cfg.MetricMount = jcfg.MetricMount

	// switch jcfg.MetricType {
	// case "reposize":
	// 	cfg.MetricType = MetricRepoSize
	// case "freespace":
	// 	cfg.MetricType = MetricFreeSpace
	// default:
	// 	return errors.New("disk.metric_type is invalid")
	// }

	return cfg.Validate()
}

// ToJSON generates a JSON-formatted human-friendly representation of this
// Config.
func (cfg *Config) ToJSON() (raw []byte, err error) {
	jcfg := cfg.toJSONConfig()

	raw, err = config.DefaultJSONMarshal(jcfg)
	return
}

func (cfg *Config) toJSONConfig() *jsonConfig {
	return &jsonConfig{
		MetricTTL:   cfg.MetricTTL.String(),
		MetricMount: cfg.MetricMount,
	}
}

// ToDisplayJSON returns JSON config as a string.
func (cfg *Config) ToDisplayJSON() ([]byte, error) {
	return config.DisplayJSON(cfg.toJSONConfig())
}

type diskStatus struct {
	All    float64 `json:"total"`
	Used   float64 `json:"used"`
	Free   float64 `json:"free"`
	Weight int64   `json:"weight"`
}

func (d *diskStatus) String() string {
	v := []string{
		`"all":` + strconv.FormatFloat(d.All, 'f', 2, 64),
		`"used":` + strconv.FormatFloat(d.Used, 'f', 2, 64),
		`"free":` + strconv.FormatFloat(d.Free, 'f', 2, 64),
		`"weight":` + strconv.FormatInt(d.Weight, 10),
	}
	// str := `"all":"` + "tem" + `"`

	return `{` + strings.Join(v, ",") + `}`
}
